# all config for srs

#############################################################################################
# RTMP sections
#############################################################################################
# the rtmp listen ports, split by space, each listen entry is <[ip:]port>
# for example, 192.168.1.100:1935 10.10.10.100:1935
# where the ip is optional, default to 0.0.0.0, that is 1935 equals to 0.0.0.0:1935
listen              1935;
# the pid file
# to ensure only one process can use a pid file
# and provides the current running process id, for script, 
# for example, init.d script to manage the server.
# default: ./objs/srs.pid
pid                 ./objs/srs.pid;
# the default chunk size is 128, max is 65536,
# some client does not support chunk size change,
# however, most clients supports it and it can improve 
# performance about 10%.
# default: 60000
chunk_size          60000;
# the logs dir.
# if enabled ffmpeg, each stracoding stream will create a log file.
# /dev/null to disable the log.
# default: ./objs
ff_log_dir          ./objs;
# the log tank, console or file.
# if console, print log to console.
# if file, write log to file. requires srs_log_file if log to file.
# default: file.
srs_log_tank        file;
# the log level, for all log tanks.
# can be: verbose, info, trace, warn, error
# default: trace
srs_log_level       trace;
# when srs_log_tank is file, specifies the log file.
# default: ./objs/srs.log
srs_log_file        ./objs/srs.log;
# the max connections.
# if exceed the max connections, server will drop the new connection.
# default: 1000
max_connections     1000;
# whether start as deamon
# @remark: donot support reload.
# default: on
daemon              on;
# whether use utc_time to generate the time struct,
# if off, use localtime() to generate it,
# if on, use gmtime() instead, which use UTC time.
# default: off
utc_time            off;
# config for the pithy print,
# which always print constant message specified by interval,
# whatever the clients in concurrency.
# default: 10000
pithy_print_ms      10000;

#############################################################################################
# heartbeat/stats sections
#############################################################################################
# heartbeat to api server
# @remark, the ip report to server, is retrieve from system stat,
#       which need the config item stats.network.
heartbeat {
    # whether heartbeat is enalbed.
    # default: off
    enabled         off;
    # the interval seconds for heartbeat,
    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....
    # default: 9.9
    interval        9.3;
    # when startup, srs will heartbeat to this api.
    # @remark: must be a restful http api url, where SRS will POST with following data:
    #   {
    #       "device_id": "my-srs-device",
    #       "ip": "192.168.1.100"
    #   }
    # default: http://127.0.0.1:8085/api/v1/servers
    url             http://127.0.0.1:8085/api/v1/servers;
    # the id of devide.
    device_id       "my-srs-device";
    # whether report with summaries
    # if on, put /api/v1/summaries to the request data:
    #   {
    #       "summaries": summaries object.
    #   }
    # @remark: optional config.
    # default: off
    summaries       off;
}

# system statistics section.
# the main cycle will retrieve the system stat,
# for example, the cpu/mem/network/disk-io data,
# the http api, for instance, /api/v1/summaries will show these data.
# @remark the heartbeat depends on the network,
#       for example, the eth0 maybe the device which index is 0.
stats {
    # the index of device ip.
    # we may retrieve more than one network device.
    # default: 0
    network         0;
    # the device name to stat the disk iops.
    # ignore the device of /proc/diskstats if not configed.
    disk            sda sdb xvda xvdb;
}

#############################################################################################
# HTTP sections
#############################################################################################
# api of srs.
# the http api config, export for external program to manage srs.
# user can access http api of srs in browser directly, for instance, to access by:
#       curl http://192.168.1.170:1985/api/v1/reload
# which will reload srs, like cmd killall -1 srs, but the js can also invoke the http api,
# where the cli can only be used in shell/terminate.
http_api {
    # whether http api is enabled.
    # default: off
    enabled         on;
    # the http api listen entry is <[ip:]port>
    # for example, 192.168.1.100:1985
    # where the ip is optional, default to 0.0.0.0, that is 1985 equals to 0.0.0.0:1985
    # default: 1985
    listen          1985;
    # whether enable crossdomain request.
    # default: on
    crossdomain     on;
    # the HTTP RAW API is more powerful api to change srs state and reload.
    raw_api {
        # whether enable the HTTP RAW API.
        # default: off
        enabled             off;
        # whether enable rpc reload.
        # default: off
        allow_reload        off;
        # whether enable rpc query.
        # default: off
        allow_query         off;
    }
}
# embeded http server in srs.
# the http streaming config, for HLS/HDS/DASH/HTTPProgressive
# global config for http streaming, user must config the http section for each vhost.
# the embed http server used to substitute nginx in ./objs/nginx,
# for example, srs runing in arm, can provides RTMP and HTTP service, only with srs installed.
# user can access the http server pages, generally:
#       curl http://192.168.1.170:80/srs.html
# which will show srs version and welcome to srs.
# @remark, the http embeded stream need to config the vhost, for instance, the __defaultVhost__
# need to open the feature http of vhost.
http_server {
    # whether http streaming service is enabled.
    # default: off
    enabled         on;
    # the http streaming listen entry is <[ip:]port>
    # for example, 192.168.1.100:8080
    # where the ip is optional, default to 0.0.0.0, that is 8080 equals to 0.0.0.0:8080
    # @remark, if use lower port, for instance 80, user must start srs by root.
    # default: 8080
    listen          8080;
    # the default dir for http root.
    # default: ./objs/nginx/html
    dir             ./objs/nginx/html;
}

#############################################################################################
# Streamer sections
#############################################################################################
# the streamer cast stream from other protocol to SRS over RTMP.
# @see https://github.com/simple-rtmp-server/srs/tree/develop#stream-architecture
stream_caster {
    # whether stream caster is enabled.
    # default: off
    enabled         off;
    # the caster type of stream, the casters:
    #       mpegts_over_udp, MPEG-TS over UDP caster.
    #       rtsp, Real Time Streaming Protocol (RTSP).
    #       flv, FLV over HTTP POST.
    caster          mpegts_over_udp;
    # the output rtmp url.
    # for mpegts_over_udp caster, the typically output url:
    #       rtmp://127.0.0.1/live/livestream
    # for rtsp caster, the typically output url:
    #       rtmp://127.0.0.1/[app]/[stream]
    #       for example, the rtsp url:
    #           rtsp://192.168.1.173:8544/live/livestream.sdp
    #           where the [app] is "live" and [stream] is "livestream", output is:
    #           rtmp://127.0.0.1/live/livestream
    output          rtmp://127.0.0.1/live/livestream;
    # the listen port for stream caster.
    #       for mpegts_over_udp caster, listen at udp port. for example, 8935.
    #       for rtsp caster, listen at tcp port. for example, 554.
    #       for flv caster, listen at tcp port. for example, 8936.
    # TODO: support listen at <[ip:]port>
    listen          8935;
    # for the rtsp caster, the rtp server local port over udp,
    # which reply the rtsp setup request message, the port will be used:
    #       [rtp_port_min, rtp_port_max)
    rtp_port_min    57200;
    rtp_port_max    57300;
}
stream_caster {
    enabled         off;
    caster          mpegts_over_udp;
    output          rtmp://127.0.0.1/live/livestream;
    listen          8935;
}
stream_caster {
    enabled         off;
    caster          rtsp;
    output          rtmp://127.0.0.1/[app]/[stream];
    listen          554;
    rtp_port_min    57200;
    rtp_port_max    57300;
}
stream_caster {
    enabled         off;
    caster          flv;
    output          rtmp://127.0.0.1/[app]/[stream];
    listen          8936;
}

#############################################################################################
# RTMP/HTTP VHOST sections
#############################################################################################
# vhost list, the __defaultVhost__ is the default vhost
# for example, user use ip to access the stream: rtmp://192.168.1.2/live/livestream.
# for which cannot identify the required vhost.
vhost __defaultVhost__ {
}

# the vhost scope configs.
vhost scope.vhost.srs.com {
    # whether the vhost is enabled.
    # if off, all request access denied.
    # default: on
    enabled         off;
    
    # whether enable min delay mode for vhost.
    # for min latence mode:
    # 1. disable the publish.mr for vhost.
    # 2. use timeout for cond wait for consumer queue.
    # @see https://github.com/simple-rtmp-server/srs/issues/257
    # default: off
    min_latency     off;
    
    # whether enable the TCP_NODELAY
    # if on, set the nodelay of fd by setsockopt
    # default: off
    tcp_nodelay     off;
    
    # the default chunk size is 128, max is 65536,
    # some client does not support chunk size change,
    # vhost chunk size will override the global value.
    # default: global chunk size.
    chunk_size      128;
}

# set the chunk size of vhost.
vhost chunksize.srs.com {
    # @see scope.vhost.srs.com
    chunk_size      128;
}

# the vhost disabled.
vhost removed.srs.com {
    # @see scope.vhost.srs.com
    enabled         off;
}



























# the vhost for antisuck.
vhost refer.anti_suck.com {
    # refer hotlink-denial.
    refer {
        # whether enable the refer hotlink-denial.
        # default: off.
        enabled         on;
        # the common refer for play and publish.
        # if the page url of client not in the refer, access denied.
        # if not specified this field, allow all.
        # default: not specified.
        all           github.com github.io;
        # refer for publish clients specified.
        # the common refer is not overrided by this.
        # if not specified this field, allow all.
        # default: not specified.
        publish   github.com github.io;
        # refer for play clients specified.
        # the common refer is not overrided by this.
        # if not specified this field, allow all.
        # default: not specified.
        play      github.com github.io;
    }
}

# vhost for bandwidth check
# generally, the bandcheck vhost must be: bandcheck.srs.com,
# or need to modify the vhost of client.
vhost bandcheck.srs.com {
    enabled         on;
    chunk_size      65000;
    # bandwidth check config.
    bandcheck {
        # whether support bandwidth check,
        # default: off.
        enabled         on;
        # the key for server to valid,
        # if invalid key, server disconnect and abort the bandwidth check.
        key             "35c9b402c12a7246868752e2878f7e0e";
        # the interval in seconds for bandwidth check,
        # server donot allow new test request.
        # default: 30
        interval        30;
        # the max available check bandwidth in kbps.
        # to avoid attack of bandwidth check.
        # default: 1000
        limit_kbps      4000;
    }
}

# the publish specified configs
vhost publish.srs.com {
    # the config for FMLE/Flash publisher, which push RTMP to SRS.
    publish {
        # about MR, read https://github.com/simple-rtmp-server/srs/issues/241
        # when enabled the mr, SRS will read as large as possible.
        # default: off
        mr          off;
        # the latency in ms for MR(merged-read),
        # the performance+ when latency+, and memory+,
        #       memory(buffer) = latency * kbps / 8
        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume
        #       memory = 500 * 3000 / 8 = 187500B = 183KB
        # when there are 2500 publisher, the total memory of SRS atleast:
        #       183KB * 2500 = 446MB
        # the value recomment is [300, 2000]
        # default: 350
        mr_latency  350;
        
        # the 1st packet timeout in ms for encoder.
        # default: 20000
        firstpkt_timeout    20000;
        # the normal packet timeout in ms for encoder.
        # default: 5000
        normal_timeout      7000;
    }
}

# the play specified configs
vhost play.srs.com {
    # for play client, both RTMP and other stream clients,
    # for instance, the HTTP FLV stream clients.
    play {
        # about the stream monotonically increasing:
        #   1. video timestamp is monotonically increasing, 
        #   2. audio timestamp is monotonically increasing,
        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.
        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format
        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.
        # the time jitter algorithm:
        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.
        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.
        #   3. off, disable the time jitter algorithm, like atc.
        # default: full
        time_jitter             full;
        # whether use the interleaved/mixed algorithm to correct the timestamp.
        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.
        # if off, use time_jitter to correct the timestamp if required.
        # default: off
        mix_correct             off;

        # vhost for atc for hls/hds/rtmp backup.
        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.
        # when atc is on, server delivery rtmp stream by absolute time.
        # atc is used, for instance, encoder will copy stream to master and slave server,
        # server use atc to delivery stream to edge/client, where stream time from master/slave server
        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,
        # if the time not the same, the HLS stream cannot slice to support system backup.
        # 
        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html
        # @see http://www.baidu.com/#wd=hds%20hls%20atc
        #
        # default: off
        atc             off;
        # whether enable the auto atc,
        # if enabled, detect the bravo_atc="true" in onMetaData packet,
        # set atc to on if matched.
        # always ignore the onMetaData if atc_auto is off.
        # default: off
        atc_auto        off;
    
        # set the MW(merged-write) latency in ms. 
        # SRS always set mw on, so we just set the latency value.
        # the latency of stream >= mw_latency + mr_latency
        # the value recomment is [300, 1800]
        # default: 350
        mw_latency      350;
    }
}

# vhost for time jitter
vhost jitter.srs.com {
    # @see play.srs.com
    time_jitter             full;
    # @see play.srs.com
    mix_correct             off;
}

# vhost for atc.
vhost atc.srs.com {
    # @see play.srs.com
    atc             on;
    # @see play.srs.com
    atc_auto        on;
}

# the MR(merged-read) setting for publisher.
# the MW(merged-write) settings for player.
vhost mrw.srs.com {
    # @see scope.vhost.srs.com
    min_latency     off;
    
    # @see play.srs.com
    play {
        mw_latency      350;
    }
    
    # @see publish.srs.com
    publish {
        mr          on;
        mr_latenct  350;
    }
}

# the vhost for min delay, donot cache any stream.
vhost min.delay.com {
    # @see scope.vhost.srs.com
    min_latency     on;
    # @see scope.vhost.srs.com
    tcp_nodelay     on;
    
    # whether cache the last gop.
    # if on, cache the last gop and dispatch to client,
    #   to enabled fast startup for client, client play immediately.
    # if off, send the latest media data to client,
    #   client need to wait for the next Iframe to decode and show the video.
    # set to off if requires min delay;
    # set to on if requires client fast startup.
    # default: on
    gop_cache       off;
    # the max live queue length in seconds.
    # if the messages in the queue exceed the max length, 
    # drop the old whole gop.
    # default: 30
    queue_length    10;
    
    # @see play.srs.com
    play {
        mw_latency      100;
    }
    
    # @see publish.srs.com
    publish {
        mr          off;
    }
}

# the vhost to control the stream delivery feature
vhost stream.control.com {
    # @see scope.vhost.srs.com
    min_latency     on;
    # @see scope.vhost.srs.com
    tcp_nodelay     on;
    
    # @see vhost min.delay.com
    queue_length    10;
    # the minimal packets send interval in ms,
    # used to control the ndiff of stream by srs_rtmp_dump,
    # for example, some device can only accept some stream which
    # delivery packets in constant interval(not cbr).
    # @remark 0 to disable the minimal interval.
    # @remark >0 to make the srs to send message one by one.
    # @remark user can get the right packets interval in ms by srs_rtmp_dump.
    # default: 0
    send_min_interval       10.0;
    # whether reduce the sequence header,
    # for some client which cannot got duplicated sequence header,
    # while the sequence header is not changed yet.
    # default: off
    reduce_sequence_header  on;
    
    # @see play.srs.com
    play {
        mw_latency      100;
    }
    
    # @see publish.srs.com
    publish {
        mr          off;
        firstpkt_timeout    20000;
        normal_timeout      7000;
    }
}

# the vhost which forward publish streams.
vhost same.vhost.forward.srs.com {
    # forward all publish stream to the specified server.
    # this used to split/forward the current stream for cluster active-standby,
    # active-active for cdn to build high available fault tolerance system.
    # format: {ip}:{port} {ip_N}:{port_N}
    forward         127.0.0.1:1936 127.0.0.1:1937;
}

# the vhost for exec, fork process when publish stream.
vhost exec.srs.com {
    # the exec used to fork process when got some event.
    exec {
        # whether enable the exec.
        # default: off.
        enabled     off;
        # when publish stream, exec the process with variables:
        #       [vhost] the input stream vhost.
        #       [port] the intput stream port.
        #       [app] the input stream app.
        #       [stream] the input stream name.
        #       [engine] the tanscode engine name.
        # other variables for exec only:
        #       [url] the rtmp url which trigger the publish.
        #       [tcUrl] the client request tcUrl.
        #       [swfUrl] the client request swfUrl.
        #       [pageUrl] the client request pageUrl.
        # @remark empty to ignore this exec.
        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;
    }
}

# the security to allow or deny clients.
vhost security.srs.com {
    # security for host to allow or deny clients.
    # @see https://github.com/simple-rtmp-server/srs/issues/211   
    security {
        # whether enable the security for vhost.
        # default: off
        enabled         on;
        # the security list, each item format as:
        #       allow|deny    publish|play    all|<ip>
        # for example:
        #       allow           publish     all;
        #       deny            publish     all;
        #       allow           publish     127.0.0.1;
        #       deny            publish     127.0.0.1;
        #       allow           play        all;
        #       deny            play        all;
        #       allow           play        127.0.0.1;
        #       deny            play        127.0.0.1;
        # SRS apply the following simple strategies one by one:
        #       1. allow all if security disabled.
        #       2. default to deny all when security enabled.
        #       3. allow if matches allow strategy.
        #       4. deny if matches deny strategy.
        allow           play        all;
        allow           publish     all;
    }
}

# vhost for edge, edge and origin is the same vhost
vhost same.edge.srs.com {
    # the mode of vhost, local or remote.
    #       local: vhost is origin vhost, which provides stream source.
    #       remote: vhost is edge vhost, which pull/push to origin.
    # default: local
    mode            remote;
    # for edge(remote mode), user must specifies the origin server
    # format as: <server_name|ip>[:port]
    # @remark user can specifies multiple origin for error backup, by space,
    # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935
    origin          127.0.0.1:1935 localhost:1935;
    # for edge, whether open the token traverse mode,
    # if token traverse on, all connections of edge will forward to origin to check(auth),
    # it's very important for the edge to do the token auth.
    # the better way is use http callback to do the token auth by the edge,
    # but if user prefer origin check(auth), the token_traverse if better solution.
    # default: off
    token_traverse  off;
}

# vhost for edge, edge transform vhost to fetch from another vhost.
vhost transform.edge.srs.com {
    mode            remote;
    origin          127.0.0.1:1935;
    # the vhost to transform for edge,
    # to fetch from the specified vhost at origin,
    # if not specified, use the current vhost of edge in origin, the variable [vhost].
    # default: [vhost]
    vhost           same.edge.srs.com;
}

# vhost for dvr
vhost dvr.srs.com {
    # dvr RTMP stream to file,
    # start to record to file when encoder publish,
    # reap flv according by specified dvr_plan.
    dvr {
        # whether enabled dvr features
        # default: off
        enabled         on;
        # the dvr plan. canbe:
        #       session reap flv when session end(unpublish).
        #       segment reap flv when flv duration exceed the specified dvr_duration.
        #       append always append to flv file, never reap it.
        # default: session
        dvr_plan        session;
        # the dvr output path.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], repleace this const to current minute.
        #       [05], repleace this const to current second.
        #       [999], repleace this const to current millisecond.
        #       [timestamp],replace this const to current UNIX timestamp in ms.
        # @remark we use golang time format "2006-01-02 15:04:05.999" as "[2006]-[01]-[02]_[15].[04].[05]_[999]"
        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776
        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):
        #       dvr_path ./objs/nginx/html;
        #       =>
        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;
        # 2. Use stream and date as dir name, time as filename:
        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;
        # 3. Use stream and year/month as dir name, date and time as filename:
        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;
        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:
        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;
        # @see https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DVR#custom-path
        # @see https://github.com/simple-rtmp-server/srs/wiki/v2_EN_DVR#custom-path
        #       segment,session apply it.
        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv
        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;
        # the duration for dvr file, reap if exeed, in seconds.
        #       segment apply it.
        #       session,append ignore.
        # default: 30
        dvr_duration    30;
        # whether wait keyframe to reap segment,
        # if off, reap segment when duration exceed the dvr_duration,
        # if on, reap segment when duration exceed and got keyframe.
        #       segment apply it.
        #       session,append ignore.
        # default: on
        dvr_wait_keyframe       on;
        # about the stream monotonically increasing:
        #   1. video timestamp is monotonically increasing, 
        #   2. audio timestamp is monotonically increasing,
        #   3. video and audio timestamp is interleaved monotonically increasing.
        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format
        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.
        # the time jitter algorithm:
        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.
        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.
        #   3. off, disable the time jitter algorithm, like atc.
        # apply for all dvr plan.
        # default: full
        time_jitter             full;
        
        # on_dvr, never config in here, should config in http_hooks.
        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DVR#http-callback
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_EN_DVR#http-callback
    }
}

# vhost for ingest
vhost ingest.srs.com {
    # ingest file/stream/device then push to SRS over RTMP.
    # the name/id used to identify the ingest, must be unique in global.
    # ingest id is used in reload or http api management.
    ingest livestream {
        # whether enabled ingest features
        # default: off
        enabled      on;
        # input file/stream/device
        # @remark only support one input.
        input {
            # the type of input.
            # can be file/stream/device, that is,
            #   file: ingest file specifies by url.
            #   stream: ingest stream specifeis by url.
            #   device: not support yet.
            # default: file
            type    file;
            # the url of file/stream.
            url     ./doc/source.200kbps.768x320.flv;
        }
        # the ffmpeg 
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        # the transcode engine, @see all.transcode.srs.com
        # @remark, the output is specified following.
        engine {
            # @see enabled of transcode engine.
            # if disabled or vcodec/acodec not specified, use copy.
            # default: off.
            enabled          off;
            # output stream. variables:
            #       [vhost] current vhost which start the ingest.
            #       [port] system RTMP stream port.
            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;
        }
    }
}

# the vhost for intest with transcode engine.
vhost transcode.ingest.srs.com {
    ingest livestream {
        enabled      on;
        input {
            type    file;
            url     ./doc/source.200kbps.768x320.flv;
        }
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled         off;
            iformat         flv;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex  'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        1500;
            vfps            25;
            vwidth          768;
            vheight         320;
            vthreads        12;
            vprofile        main;
            vpreset         medium;
            vparams {
                t               100;
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
                profile:a   aac_low;
            }
            oformat         flv;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream];
        }
    }
}

# vhost for http static and flv vod stream for each vhost.
vhost http.static.srs.com {
    # http static vhost specified config
    http_static {
        # whether enabled the http static service for vhost.
        # default: off
        enabled     on;
        # the url to mount to, 
        # typical mount to [vhost]/
        # the variables:
        #       [vhost] current vhost for http server.
        # @remark the [vhost] is optional, used to mount at specified vhost.
        # @remark the http of __defaultVhost__ will override the http_server section.
        # for example:
        #       mount to [vhost]/
        #           access by http://ossrs.net:8080/xxx.html
        #       mount to [vhost]/hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #       mount to /
        #           access by http://ossrs.net:8080/xxx.html
        #           or by http://192.168.1.173:8080/xxx.html
        #       mount to /hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #           or by http://192.168.1.173:8080/hls/xxx.html
        # @remark the port of http is specified by http_server section.
        # default: [vhost]/
        mount       [vhost]/hls;
        # main dir of vhost,
        # to delivery HTTP stream of this vhost.
        # default: ./objs/nginx/html
        dir         ./objs/nginx/html/hls;
    }
}

# vhost for http flv/aac/mp3 live stream for each vhost.
vhost http.remux.srs.com {
    # http flv/mp3/aac/ts stream vhost specified config
    http_remux {
        # whether enable the http live streaming service for vhost.
        # default: off
        enabled     on;
        # the fast cache for audio stream(mp3/aac),
        # to cache more audio and send to client in a time to make android(weixin) happy.
        # @remark the flv/ts stream ignore it
        # @remark 0 to disable fast cache for http audio stream.
        # default: 0
        fast_cache  30;
        # the stream mout for rtmp to remux to live streaming.
        # typical mount to [vhost]/[app]/[stream].flv
        # the variables:
        #       [vhost] current vhost for http live stream.
        #       [app] current app for http live stream.
        #       [stream] current stream for http live stream.
        # @remark the [vhost] is optional, used to mount at specified vhost.
        # the extension:
        #       .flv mount http live flv stream, use default gop cache.
        #       .ts mount http live ts stream, use default gop cache.
        #       .mp3 mount http live mp3 stream, ignore video and audio mp3 codec required.
        #       .aac mount http live aac stream, ignore video and audio aac codec required.
        # for example:
        #       mount to [vhost]/[app]/[stream].flv
        #           access by http://ossrs.net:8080/live/livestream.flv
        #       mount to /[app]/[stream].flv
        #           access by http://ossrs.net:8080/live/livestream.flv
        #           or by http://192.168.1.173:8080/live/livestream.flv
        #       mount to [vhost]/[app]/[stream].mp3
        #           access by http://ossrs.net:8080/live/livestream.mp3
        #       mount to [vhost]/[app]/[stream].aac
        #           access by http://ossrs.net:8080/live/livestream.aac
        #       mount to [vhost]/[app]/[stream].ts
        #           access by http://ossrs.net:8080/live/livestream.ts
        # @remark the port of http is specified by http_server section.
        # default: [vhost]/[app]/[stream].flv
        mount       [vhost]/[app]/[stream].flv;
        # whether http stream trigger rtmp stream source when no stream available,
        # for example, when encoder has not publish stream yet,
        # user can play the http flv stream and wait for stream.
        # default: on
        hstrs       on;
    }
}

# the vhost with hls specified.
vhost with-hls.srs.com {
    hls {
        # whether the hls is enabled.
        # if off, donot write hls(ts and m3u8) when publish.
        # default: off
        enabled         on;
        # the hls fragment in seconds, the duration of a piece of ts.
        # default: 10
        hls_fragment    10;
        # the hls m3u8 target duration ratio,
        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init
        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts
        # @see https://github.com/simple-rtmp-server/srs/issues/304#issuecomment-74000081
        # default: 1.5
        hls_td_ratio    1.5;
        # the audio overflow ratio.
        # for pure audio, the duration to reap the segment.
        # for example, the hls_fragment is 10s, hsl_aof_ratio is 2.0,
        # the segemnt will reap to 20s for pure audio.
        # default: 2.0
        hls_aof_ratio   2.0;
        # the hls window in seconds, the number of ts in m3u8.
        # default: 60
        hls_window      60;
        # the error strategy. canbe:
        #       ignore, when error ignore and disable hls.
        #       disconnect, when error disconnect the publish connection.
        #       continue, when error ignore and continue output hls.
        # @see https://github.com/simple-rtmp-server/srs/issues/264
        # default: ignore
        hls_on_error    ignore;
        # the hls storage: disk, ram or both.
        #       disk, to write hls m3u8/ts to disk.
        #       ram, serve m3u8/ts in memory, which use embeded http server to delivery.
        #       both, disk and ram.
        # default: disk
        hls_storage     disk;
        # the hls output path.
        # the m3u8 file is configed by hls_path/hls_m3u8_file, the default is:
        #       ./objs/nginx/html/[app]/[stream].m3u8
        # the ts file is configed by hls_path/hls_ts_file, the default is:
        #       ./objs/nginx/html/[app]/[stream]-[seq].ts
        # @remark the hls_path is compatible with srs v1 config.
        # default: ./objs/nginx/html
        hls_path        ./objs/nginx/html;
        # the hls m3u8 file name.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        # default: [app]/[stream].m3u8
        hls_m3u8_file   [app]/[stream].m3u8;
        # the hls ts file name.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], repleace this const to current minute.
        #       [05], repleace this const to current second.
        #       [999], repleace this const to current millisecond.
        #       [timestamp],replace this const to current UNIX timestamp in ms.
        #       [seq], the sequence number of ts.
        # @see https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DVR#custom-path
        # @see https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DeliveryHLS#hls-config
        # default: [app]/[stream]-[seq].ts
        hls_ts_file     [app]/[stream]-[seq].ts;
        # whether use floor for the hls_ts_file path generation.
        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],
        #       and use enahanced algorithm to calc deviation for segment.
        # @remark when floor on, recommend the hls_segment>=2*gop.
        # default: off
        hls_ts_floor    off;
        # the hls entry prefix, which is base url of ts url.
        # if specified, the ts path in m3u8 will be like:
        #         http://your-server/live/livestream-0.ts
        #         http://your-server/live/livestream-1.ts
        #         ...
        # optional, default to empty string.
        hls_entry_prefix http://your-server;
        # the hls mount for hls_storage ram,
        # which use srs embeded http server to delivery HLS,
        # where the mount specifies the HTTP url to mount.
        # @see the mount of http_remux.
        # @remark the hls_mount must endswith .m3u8.
        # default: [vhost]/[app]/[stream].m3u8
        hls_mount       [vhost]/[app]/[stream].m3u8;
        # the default audio codec of hls.
        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.
        # so user can set the default codec for mp3.
        # the available audio codec: 
        #       aac, mp3, an
        # default: aac
        hls_acodec      aac;
        # the default video codec of hls.
        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.
        # so user can set the default codec for pure audio(without video) to vn.
        # the available video codec:
        #       h264, vn
        # default: h264
        hls_vcodec      h264;
        # whether cleanup the old expired ts files.
        # default: on
        hls_cleanup     on;
        # the timeout in seconds to dispose the hls,
        # dispose is to remove all hls files, m3u8 and ts files.
        # when publisher timeout dispose hls.
        # @remark 0 to disable dispose for publisher.
        # @remark apply for publisher timeout only, while "etc/init.d/srs stop" always dispose hls.
        # default: 0
        hls_dispose     0;
        # the max size to notify hls,
        # to read max bytes from ts of specified cdn network,
        # @remark only used when on_hls_notify is config.
        # default: 64
        hls_nb_notify   64;
        # whether wait keyframe to reap segment,
        # if off, reap segment when duration exceed the fragment,
        # if on, reap segment when duration exceed and got keyframe.
        # default: on
        hls_wait_keyframe       on;

        # on_hls, never config in here, should config in http_hooks.
        # for the hls http callback, @see http_hooks.on_hls of vhost hooks.callback.srs.com
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DeliveryHLS#http-callback
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_EN_DeliveryHLS#http-callback
        
        # on_hls_notify, never config in here, should config in http_hooks.
        # we support the variables to generate the notify url:
        #       [app], replace with the app.
        #       [stream], replace with the stream.
        #       [ts_url], replace with the ts url.
        # for the hls http callback, @see http_hooks.on_hls_notify of vhost hooks.callback.srs.com
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_CN_DeliveryHLS#on-hls-notify
        # @read https://github.com/simple-rtmp-server/srs/wiki/v2_EN_DeliveryHLS#on-hls-notify
    }
}
# the vhost with hls disabled.
vhost no-hls.srs.com {
    hls {
        # whether the hls is enabled.
        # if off, donot write hls(ts and m3u8) when publish.
        # default: off
        enabled         off;
    }
}

# the vhost with adobe hds
vhost hds.srs.com {
    hds {
        # whether hds enabled
        # default: off
        enabled         on;
        # the hds fragment in seconds.
        # default: 10
        hds_fragment    10;
        # the hds window in seconds, erase the segment when exceed the window.
        # default: 60
        hds_window      60;
        # the path to store the hds files.
        # default: ./objs/nginx/html
        hds_path        ./objs/nginx/html;
    }
}

# the http hook callback vhost, srs will invoke the hooks for specified events.
vhost hooks.callback.srs.com {
    http_hooks {
        # whether the http hooks enalbe.
        # default off.
        enabled         on;
        # when client connect to vhost/app, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_connect",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "tcUrl": "rtmp://video.test.com/live?key=d2fa801d08e3f90ed1e1670e6e52651a",
        #           "pageUrl": "http://www.test.com/live.html"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_connect http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_connect      http://127.0.0.1:8085/api/v1/clients http://localhost:8085/api/v1/clients;
        # when client close/disconnect to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_close",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "send_bytes": 10240, "recv_bytes": 10240
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_close http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_close        http://127.0.0.1:8085/api/v1/clients http://localhost:8085/api/v1/clients;
        # when client(encoder) publish to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_publish",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_publish http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;
        # when client(encoder) stop publish to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_unpublish",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_unpublish http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;
        # when client start to play vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_play",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream",
        #           "pageUrl": "http://www.test.com/live.html"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_play http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;
        # when client stop to play vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_stop",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_stop http://xxx/api0 http://xxx/api1 http://xxx/apiN
        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;
        # when srs reap a dvr file, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_dvr",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream",
        #           "cwd": "/usr/local/srs",
        #           "file": "./objs/nginx/html/live/livestream.1420254068776.flv"
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;
        # when srs reap a ts file of hls, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_hls",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream",
        #           "duration": 9.36, // in seconds
        #           "cwd": "/usr/local/srs",
        #           "file": "./objs/nginx/html/live/livestream/2015-04-23/01/476584165.ts",
        #           "url": "live/livestream/2015-04-23/01/476584165.ts",
        #           "m3u8": "./objs/nginx/html/live/livestream/live.m3u8",
        #           "m3u8_url": "live/livestream/live.m3u8",
        #           "seq_no": 100
        #       }
        # if valid, the hook must return HTTP code 200(Stauts OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;
        # when srs reap a ts file of hls, call this hook,
        # used to push file to cdn network, by get the ts file from cdn network.
        # so we use HTTP GET and use the variable following:
        #       [app], replace with the app.
        #       [stream], replace with the stream.
        #       [ts_url], replace with the ts url.
        # ignore any return data of server.
        # @remark random select a url to report, not report all.
        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];
    }
}

# the vhost for srs debug info, whether send args in connect(tcUrl).
vhost debug.srs.com {
    # when upnode(forward to, edge push to, edge pull from) is srs,
    # it's strongly recommend to open the debug_srs_upnode,
    # when connect to upnode, it will take the debug info, 
    # for example, the id, source id, pid.
    # please see: https://github.com/simple-rtmp-server/srs/wiki/v1_CN_SrsLog
    # default: on
    debug_srs_upnode    on;
}

# the main comments for transcode
vhost example.transcode.srs.com {
    # the streaming transcode configs.
    transcode {
        # whether the transcode enabled.
        # if off, donot transcode.
        # default: off.
        enabled     on;
        # the ffmpeg 
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        # the transcode engine for matched stream.
        # all matched stream will transcoded to the following stream.
        # the transcode set name(ie. hd) is optional and not used.
        engine example {
            # whether the engine is enabled
            # default: off.
            enabled         on;
            # input format, can be:
            # off, do not specifies the format, ffmpeg will guess it.
            # flv, for flv or RTMP stream.
            # other format, for example, mp4/aac whatever.
            # default: flv
            iformat         flv;
            # ffmpeg filters, follows the main input.
            vfilter {
                # the logo input file.
                i               ./doc/ffmpeg-logo.png;
                # the ffmpeg complex filter.
                # for filters, @see: http://ffmpeg.org/ffmpeg-filters.html
                filter_complex  'overlay=10:10';
            }
            # video encoder name. can be:
            #       libx264: use h.264(libx264) video encoder.
            #       copy: donot encoder the video stream, copy it.
            #       vn: disable video output.
            vcodec          libx264;
            # video bitrate, in kbps
            # @remark 0 to use source video bitrate.
            # default: 0
            vbitrate        1500;
            # video framerate.
            # @remark 0 to use source video fps.
            # default: 0
            vfps            25;
            # video width, must be even numbers.
            # @remark 0 to use source video width.
            # default: 0
            vwidth          768;
            # video height, must be even numbers.
            # @remark 0 to use source video height.
            # default: 0
            vheight         320;
            # the max threads for ffmpeg to used.
            # default: 1
            vthreads        12;
            # x264 profile, @see x264 -help, can be:
            # high,main,baseline
            vprofile        main;
            # x264 preset, @see x264 -help, can be: 
            #       ultrafast,superfast,veryfast,faster,fast
            #       medium,slow,slower,veryslow,placebo
            vpreset         medium;
            # other x264 or ffmpeg video params
            vparams {
                # ffmpeg options, @see: http://ffmpeg.org/ffmpeg.html
                t               100;
                # 264 params, @see: http://ffmpeg.org/ffmpeg-codecs.html#libx264
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            # audio encoder name. can be:
            #       libfdk_aac: use aac(libfdk_aac) audio encoder.
            #       copy: donot encoder the audio stream, copy it.
            #       an: disable audio output.
            acodec          libfdk_aac;
            # audio bitrate, in kbps. [16, 72] for libfdk_aac.
            # @remark 0 to use source audio bitrate.
            # default: 0
            abitrate        70;
            # audio sample rate. for flv/rtmp, it must be:
            #       44100,22050,11025,5512
            # @remark 0 to use source audio sample rate.
            # default: 0
            asample_rate    44100;
            # audio channel, 1 for mono, 2 for stereo.
            # @remark 0 to use source audio channels.
            # default: 0
            achannels       2;
            # other ffmpeg audio params
            aparams {
                # audio params, @see: http://ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders
                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2
                profile:a   aac_low;
                bsf:a       aac_adtstoasc;
            }
            # output format, can be:
            #       off, do not specifies the format, ffmpeg will guess it.
            #       flv, for flv or RTMP stream.
            #       other format, for example, mp4/aac whatever.
            # default: flv
            oformat         flv;
            # output stream. variables:
            #       [vhost] the input stream vhost.
            #       [port] the intput stream port.
            #       [app] the input stream app.
            #       [stream] the input stream name.
            #       [engine] the tanscode engine name.
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the mirror filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#Filtering-Introduction
vhost mirror.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine mirror {
            enabled         on;
            vfilter {
                vf                  'split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the drawtext filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#drawtext-1
# remark: we remove the libfreetype which always cause build failed, you must add it manual if needed.
#######################################################################################################
# the crop filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#crop
vhost crop.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine crop {
            enabled         on;
            vfilter {
                vf                  'crop=in_w-20:in_h-160:10:80';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the logo filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#overlay
vhost logo.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine logo {
            enabled         on;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex      'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# audio transcode only.
# for example, FMLE publish audio codec in mp3, and donot support HLS output,
# we can transcode the audio to aac and copy video to the new stream with HLS.
vhost audio.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine acodec {
            enabled         on;
            vcodec          copy;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# disable video, transcode/copy audio.
# for example, publish pure audio stream.
vhost vn.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine vn {
            enabled         on;
            vcodec          vn;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# ffmpeg-copy(forward implements by ffmpeg).
# copy the video and audio to a new stream.
vhost copy.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine copy {
            enabled         on;
            vcodec          copy;
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# transcode all app and stream of vhost
# the comments, read example.transcode.srs.com
vhost all.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine ffsuper {
            enabled         on;
            iformat         flv;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex  'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        1500;
            vfps            25;
            vwidth          768;
            vheight         320;
            vthreads        12;
            vprofile        main;
            vpreset         medium;
            vparams {
                t               100;
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
                profile:a   aac_low;
            }
            oformat         flv;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine ffhd {
            enabled         on;
            vcodec          libx264;
            vbitrate        1200;
            vfps            25;
            vwidth          1382;
            vheight         576;
            vthreads        6;
            vprofile        main;
            vpreset         medium;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine ffsd {
            enabled         on;
            vcodec          libx264;
            vbitrate        800;
            vfps            25;
            vwidth          1152;
            vheight         480;
            vthreads        4;
            vprofile        main;
            vpreset         fast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        60;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine fffast {
            enabled     on;
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine vcopy {
            enabled         on;
            vcodec          copy;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine acopy {
            enabled     on;
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine copy {
            enabled         on;
            vcodec          copy;
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# transcode all stream using the empty ffmpeg demo, donothing.
vhost ffempty.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg ./objs/research/ffempty;
        engine empty {
            enabled         on;
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# transcode all app and stream of app
vhost app.transcode.srs.com {
    # the streaming transcode configs.
    # if app specified, transcode all streams of app.
    transcode live {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled     off;
        }
    }
}
# transcode specified stream.
vhost stream.transcode.srs.com {
    # the streaming transcode configs.
    # if stream specified, transcode the matched stream.
    transcode live/livestream {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled     off;
        }
    }
}
